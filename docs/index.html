<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Binary Relations: Binary relations are everywhere</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Binary Relations
   </div>
   <div id="projectbrief">Three new associative container classes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Binary relations are everywhere </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2_users_2rpieket_2_dropbox_2_projects_2_binary_relations_2_r_e_a_d_m_e"></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
What is this?</h1>
<p>This is a small C++ library (a single header file) that adds three new associative container types that help you organize and query data in memory.</p>
<ul>
<li>Released under MIT License.</li>
<li><a href="https://ronpieket.github.io/BinaryRelations/class_binary_relations_1_1_one_to_many.html">Click here for the documentation.</a></li>
<li><a href="https://github.com/RonPieket/BinaryRelations">Click here for the GitHub repo.</a></li>
<li>This library uses <code>std::vector</code> and <code>std::unordered_map</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Intro</h1>
<p>There is a data structure I that has served me very well for many years in the Insomniac Core tools group. I don’t hear other programmers refer to it, so I want to introduce it to you. I call it a binary relation. It’s a bidirectional associative container.</p>
<p>The term “binary relation” and the concept are borrowed from mathematics, specifically set theory. But this is not a library for mathematicians. It is for programmers needing to organize their data.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
A quick refresher</h1>
<p>Binary relations are the association between elements of two sets. It can be projected as a set consisting of related pairs (x,y) where x is the input or the domain and where y is the output or the range. The notation x R y means that x is related to y by R, where R can be the relation that links x and y.</p>
<p><img src="binary-relations.png" alt="" class="inline"/></p>
<p>In this library x and y are called left and right, indicating their position in the diagram.</p>
<p>There are four kinds of binary relations. They are: one-to-one, one-to-many, many-to-one, and many-to-many. But because one-to-many and many-to-one are interchangeable if you swap the left and the right side, we ignore many-to-one. You won’t need it, as will become clear later.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Real world examples</h1>
<p>The real world examples come from my experience as a game tools programmer, specifically as a programmer of the Insomniac world editor. So I will use that as an example.</p>
<p>So in the world editor then, every object in the world is represented by a handle. They need to be organized at the global level. For example, objects can be connected in a parent-child relationship. A parent object can have any number of children. Each child has exactly one parent. This is a binary relation, a one-to-many. And each child may itself be a parent and have children. So we have a hierarchy tree.</p>
<p>Typically, this is kind of relationship is expressed in the object data itself. Every object that is a child contains a handle (or pointer) to a parent. And each parent contains an array of handles (or pointers) to its children.</p>
<div class="fragment"><div class="line">class GameObject</div>
<div class="line">{</div>
<div class="line">    Handle m_Parent;</div>
<div class="line">    std::vector&lt;Handle&gt; m_Children;</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p>This organization requires that when a child changes parent, you need to update both the <code>m_Parent</code> of the child as well as the <code>m_Children</code> list of the parent. This kind of connection is a one-to-many binary relation. With binary relations, the relationship between parents and children is stored outside of the object data structure, in its own container. All parent-to-child relationships are stored in one container that lives alongside the game objects.</p>
<div class="fragment"><div class="line">class World</div>
<div class="line">{</div>
<div class="line">    OneToMany&lt;Handle, Handle&gt; m_ParentToChildren;</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p>With this data structure, you can look up the parent handle for any object, and get a list of handles of its children.</p>
<p>This is a key concept, and I want to emphasize it here: relations between objects (such as parent-child) are not stored in the objects, but in a separate worldwide relationship table.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Binary relations are everywhere</h1>
<p>Once you get the hang of storing relationships outside of the object, you will find uses for it everywhere. For example, game objects can be member of multiple groups. That’s a many-to-many. Given the group’s handle, you can look up all its members. And when you have a game object, you can get a list of the groups it belongs to.</p>
<p>Perhaps a more surprising example is this. Say you have an object type to classify people, vehicles, and buildings. This, too, is a binary relation. In this case it’s a one-to-many. Given an object handle, you can look up what type it is. Given an object type, you can get a list of all objects of that type.</p>
<p>Here are some more use cases:</p>
<div class="fragment"><div class="line">class World</div>
<div class="line">{</div>
<div class="line">    OneToMany&lt;Handle, Handle&gt;     m_ParentToChildren;</div>
<div class="line">    OneToMany&lt;ZoneId, Handle&gt;     m_ZoneToObjects;</div>
<div class="line">    OneToMany&lt;ObjectType, Handle&gt; m_TypeToObjects;</div>
<div class="line">    OneToMany&lt;AssetInfo, Handle&gt;  m_AssetToObjects;</div>
<div class="line">    OneToMany&lt;AssetInfo, Handle&gt;  m_ZoneToObjects;</div>
<div class="line">    OneToMany&lt;Handle, Handle&gt;     m_PrefabToObjects;</div>
<div class="line">    OneToMany&lt;AssetType, Handle&gt;  m_AssetTypeToObjects;</div>
<div class="line">    ...</div>
<div class="line">    ManyToMany&lt;Handle, Handle&gt;    m_GroupsToObjects;</div>
<div class="line">    ManyToMany&lt;QuestId, Handle&gt;   m_QuestsToGroups;</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5"></a>
The API</h1>
<p>The library is located in the BinaryRelations directory. It consists of a single C++ header file. There are three class templates that you need to know of. The classes are: OneToMany, ManyToMany, and OneToOne.</p>
<p>Each binary relation type is a template, with type arguments <code>LeftType</code> and <code>RightType</code>. <b>Both types need to be small, hashable, and immutable.</b> I recommend that you only use simple types, such as <code>int</code> and <code>enum</code>, and possibly <code>std::string</code>.</p>
<p>This is the entire OneToMany API. OneToOne and ManyToMany are near identical. <a href="https://ronpieket.github.io/BinaryRelations">Click here for the full documentation.</a></p>
<div class="fragment"><div class="line">OneToMany:</div>
<div class="line"> </div>
<div class="line">void     insert(const Pair &amp;pair)</div>
<div class="line">void     insert(const LeftType &amp;left, const RightType &amp;right)</div>
<div class="line">void     insert(const OneToMany&lt;LeftType, RightType&gt; &amp;other)</div>
<div class="line">void     remove(const Pair &amp;pair)</div>
<div class="line">void     remove(const LeftType &amp;left, const RightType &amp;right)</div>
<div class="line">void     removeLeft(const LeftType &amp;left)</div>
<div class="line">void     removeRight(const RightType &amp;right)</div>
<div class="line">void     remove(const OneToMany&lt;LeftType, RightType&gt; &amp;other)</div>
<div class="line">void     clear()</div>
<div class="line">bool     contains(const Pair &amp;pair) const</div>
<div class="line">bool     contains(const LeftType &amp;left, const RightType &amp;right) const</div>
<div class="line">bool     containsLeft(const LeftType &amp;left) const</div>
<div class="line">bool     containsRight(const RightType &amp;right) const</div>
<div class="line">int      countLeft() const</div>
<div class="line">int      countRight() const</div>
<div class="line">int      count() const</div>
<div class="line"> </div>
<div class="line">UnorderedMapHelper&lt;LeftType, std::vector&lt;RightType&gt; *&gt; allLeft()Iterator </div>
<div class="line">UnorderedMapHelper&lt;RightType, LeftType&gt; AllRight()</div>
<div class="line">LeftType findLeft(const RightType &amp;right, const LeftType &amp;notFoundValue) const</div>
<div class="line">const std::vector&lt;RightType&gt;* findRight(const LeftType &amp;left) const</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Installation and usage</h1>
<div class="fragment"><div class="line">#include &quot;BinaryRelations/BinaryRelations.h&quot;</div>
</div><!-- fragment --><p>That’s all.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Code example</h1>
<div class="fragment"><div class="line">    enum VehicleMake { kUnknownMake, kVolvo, kNissan, kFord };</div>
<div class="line">    enum OccupantType { kUnknownType, kDriver, kPassenger };</div>
<div class="line"> </div>
<div class="line">    OneToMany&lt;VehicleMake, std::string&gt; VehicleToOccupants;</div>
<div class="line">    OneToMany&lt;OccupantType, std::string&gt; TypeToOccupants;</div>
<div class="line"> </div>
<div class="line">    VehicleToOccupants.insert(kVolvo, &quot;Liz&quot;);</div>
<div class="line">    VehicleToOccupants.insert(kVolvo, &quot;Joe&quot;);</div>
<div class="line">    VehicleToOccupants.insert(kVolvo, &quot;Sal&quot;);</div>
<div class="line">    VehicleToOccupants.insert(kNissan, &quot;Ben&quot;);</div>
<div class="line">    VehicleToOccupants.insert(kNissan, &quot;Eva&quot;);</div>
<div class="line">    VehicleToOccupants.insert(kFord, &quot;Amy&quot;);</div>
<div class="line"> </div>
<div class="line">    TypeToOccupants.insert(kDriver, &quot;Liz&quot;);</div>
<div class="line">    TypeToOccupants.insert(kPassenger, &quot;Joe&quot;);</div>
<div class="line">    TypeToOccupants.insert(kPassenger, &quot;Sal&quot;);</div>
<div class="line">    TypeToOccupants.insert(kDriver, &quot;Ben&quot;);</div>
<div class="line">    TypeToOccupants.insert(kPassenger, &quot;Eva&quot;);</div>
<div class="line">    TypeToOccupants.insert(kDriver, &quot;Amy&quot;);</div>
<div class="line"> </div>
<div class="line">    // List just the drivers</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;Drivers are:&quot; &lt;&lt; std::endl;</div>
<div class="line">    for (std::string name : *TypeToOccupants.findRight(kDriver))</div>
<div class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    // List all occupant info</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;Occupants are:&quot; &lt;&lt; std::endl;</div>
<div class="line">    for (std::string name : VehicleToOccupants.allRight())</div>
<div class="line">        std::cout &lt;&lt; name</div>
<div class="line">        &lt;&lt; &quot; is a &quot; &lt;&lt; TypeToOccupants.findLeft(name, kUnknownType)</div>
<div class="line">        &lt;&lt; &quot; in the &quot; &lt;&lt; VehicleToOccupants.findLeft(name, kUnknownMake)</div>
<div class="line">        &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    // List all vehicles</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;Vehicles are:&quot; &lt;&lt; std::endl;</div>
<div class="line">    for (auto vehicle : VehicleToOccupants.allLeft())</div>
<div class="line">        std::cout &lt;&lt; vehicle &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Output:</p>
<div class="fragment"><div class="line">Drivers are:</div>
<div class="line">Amy</div>
<div class="line">Ben</div>
<div class="line">Liz</div>
<div class="line">Occupants are:</div>
<div class="line">Amy is a 1 in the 3</div>
<div class="line">Eva is a 2 in the 2</div>
<div class="line">Ben is a 1 in the 2</div>
<div class="line">Joe is a 2 in the 1</div>
<div class="line">Sal is a 2 in the 1</div>
<div class="line">Liz is a 1 in the 1</div>
<div class="line">Vehicles are:</div>
<div class="line">3</div>
<div class="line">2</div>
<div class="line">1</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Naming</h1>
<p>This is a suggestion.</p>
<p>In the code example, note that the name of the OneToMany has the form of “SingleToPlural”, like “VehicleToOccupants”. Similarly, ManyToMany names would be “PluralToPlural”, OneToOne would be “SingleToSingle”.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Efficiency</h1>
<p>The efficiency for lookup such as <code>FindLeft()</code> and <code>FindRight()</code> is constant time. All operations on a OneToOne are also constant.</p>
<p>Things get more complicated with OneToMany and ManyToMany. They maintain sorted arrays. Insertion and removal of elements in an array involves shifting everything between the point of insertion/removal and the end of the array. In practice, at least in the context of our world editor, this has not been a problem. That’s probably because insert and remove operations are relatively infrequent when compared to lookups. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
